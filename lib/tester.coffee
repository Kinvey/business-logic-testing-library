# Copyright (c) 2014, Kinvey, Inc. All rights reserved.
#
# This software is licensed to you under the Kinvey terms of service located at
# http://www.kinvey.com/terms-of-use. By downloading, accessing and/or using this
# software, you hereby accept such terms of service  (and any agreement referenced
# therein) and agree that you have read, understand and agree to be bound by such
# terms of service and are of legal age to agree to such terms with Kinvey.
#
# This software contains valuable confidential and proprietary information of
# KINVEY, INC and is subject to applicable licensing agreements.
# Unauthorized reproduction, transmission or distribution of this file and its
# contents is a violation of applicable laws.

fs = require 'fs'
net = require 'net'
path = require 'path'
exec = require('child_process').exec
uuid = require 'uuid'
clone = require 'clone'
config = require 'config'
KinveyMockRequest = require './mock-request-builder'
KinveyMockResponse = require './mock-response-builder'
KinveyDataStore = require './data-store'

sendJSONTaskToContainer = (containerHostOrIP, runnerPort, jsonTask, callback) ->
  # TODO: Better TCP handling/error capturing
  containerSocket = net.createConnection runnerPort, containerHostOrIP, () ->
    buffer = ''

    containerSocket.on 'data', (chunk) ->
      chunk = chunk.toString 'utf8'
      if chunk.indexOf('\n') is -1
        buffer += chunk
        return

      buffer += chunk.slice(0, chunk.indexOf('\n') - 1)

      try
        parsedData = JSON.parse buffer
      catch e
        e.message = 'Could not parse JSON response. ' + e.message
        return callback e

      if not parsedData?.taskId and parsedData?.metadata?.taskId
        parsedData.taskId = parsedData.metadata.taskId

      containerSocket.end()

      # TODO: Figure out how errors are sent back
      if parsedData?.isError?
        return callback parsedData

      callback null, parsedData

    containerSocket.write JSON.stringify jsonTask
    containerSocket.write '\n'

  # Socker error handler.
  containerSocket.on 'error', callback

getCommonBLCode = (blRootPath) ->
  try
    fullPathToCommonFiles = path.join blRootPath, config.directories.pathToCommonFiles
    commonFiles = fs.readdirSync fullPathToCommonFiles
  catch error
    return '' # if there are no common files, we're done

  commonBL = ''
  for fileName in commonFiles
    commonBL += fs.readFileSync path.join(fullPathToCommonFiles, fileName), { encoding: 'utf8' }
    commonBL += '\n;' # delimit content of files
  return commonBL

runBLCodeString = (configuration, blCodeString, isCollectionHook, collectionOrEndpointName, blFunctionName, request, response, callback) ->
  if request? then request = clone request
  if response? then response = clone response

  # accept requests generated by the helper module
  if request instanceof KinveyMockRequest
    request = request.toJSON?()

  # request defaults
  request ?= {}
  request.headers ?= {}
  request.body ?= {}
  request.params ?= {}
  request.tempObjectStore ?= {}
  request.username ?= 'testUsername'
  request.entityId = request.params.id ? request.params.userid

  unless request.method?
    switch blFunctionName
      when 'onRequest', 'onPreSave', 'onPostSave' then request.method = 'POST'
      when 'onPreFetch', 'onPostFetch' then request.method = 'GET'
      when 'onPreDelete', 'onPostDelete' then request.method = 'DELETE'

  unless request.collectionName?
    request.collectionName = collectionOrEndpointName

  # accept responses generated by the helper module
  if response instanceof KinveyMockResponse
    response = response.toJSON?()

  # response defaults
  response ?= {}
  response.status ?= 0
  response.headers ?= {}
  response.body ?= {}

  task =
    appId: configuration.environmentID
    appMetadata:
      _id: configuration.environmentID
      appsecret: configuration.appSecret
      mastersecret: configuration.masterSecret
    blScript: blCodeString
    proxyURL: "http://#{configuration.containerHostOrIP}:#{configuration.proxyPort}"
    request: request
    response: response
    targetFunction: blFunctionName
    taskId: uuid()

  # TO BE REMOVED (once it's gone from core/api)
  task.collectionName = collectionOrEndpointName
  if isCollectionHook
    task.hookType = 'collectionHook'
  else
    task.hookType = 'customEndpoint'
  # /TO BE REMOVED

  sendJSONTaskToContainer configuration.containerHostOrIP, configuration.runnerPort, task, (err, jsonResponseFromBL) ->
    if err then return callback err

    # jsonResponseFromBL is the response emitted from the business-logic-api module.
    # it contains 'metadata', 'request' and 'response' properties, each containing JSON.
    callback null, jsonResponseFromBL

getCodeStringFromFilesystem = (blRootPath, subfolderName, fileName, callback) ->
  try
    codeString = getCommonBLCode blRootPath
    codeString += fs.readFileSync path.join(blRootPath, subfolderName, fileName + '.js'), { encoding: 'utf8' }
  catch error
    error.name = 'BLFileNotFoundError' # change the name, making the error a bit more descriptive
    throw error

  return codeString

class KinveyBusinessLogicClient
  constructor: (options = {}, callback) ->
    @configuration = {}

    if not options.blRootPath? or not fs.existsSync options.blRootPath
      unless options.quiet
        console.log 'WARNING: blRootPath not specified or path does not exist. You will not be able to run BL code from your BL files'

    unless options.environmentID?
      options.environmentID = config.environmentID
      unless options.quiet
        console.log "WARNING: environmentID not specified, running BL in the context of the default #{options.environmentID} environment"

    unless options.containerHostOrIP?
      dockerHost = process.env.DOCKER_HOST?.match?(/^(?:[a-z]+:\/\/)?(\S+):/)?[1] # matches ^(protocol://)?host-or-ip:*
      if dockerHost?
        options.containerHostOrIP = dockerHost
        unless options.quiet
          console.log "WARNING: containerHostOrIP not specified, using environment variable DOCKER_HOST (#{options.containerHostOrIP})"
      else
        options.containerHostOrIP = config.containerHostOrIP
        unless options.quiet
          console.log "WARNING: containerHostOrIP not specified and environment variable DOCKER_HOST not set, using default of #{options.containerHostOrIP}"

    exec 'docker ps', (err, stdout, stderr) =>
      if err
        unless options.quiet
          console.log "WARNING: unable to run 'docker ps' command. Encountered error:", err
        return callback err

      # returns an array with mapping strings: ['43525->2875', '38545->7000']
      portMappingStrings = stdout?.toString()?.match?(/(\d+)->(\d+)/g)

      if portMappingStrings?
        portMappings = {}
        # populate such that portMappings[hostPort] = internalContainerPort
        for mappingString in portMappingStrings
          ports = mappingString.split '->'
          portMappings[ports[1]] = ports[0]

      unless options.runnerPort?
        options.runnerPort = portMappings?[config.runnerPort] ? config.runnerPort
        unless options.quiet
          console.log "WARNING: runnerPort not specified, using default of #{options.runnerPort} (mapped to #{config.runnerPort})"

      unless options.proxyPort?
        options.proxyPort = portMappings?[config.proxyPort] ? config.proxyPort
        unless options.quiet
          console.log "WARNING: proxyPort not specified, using default of #{options.proxyPort} (mapped to #{config.proxyPort})"

      @configuration.containerHostOrIP = options.containerHostOrIP
      @configuration.runnerPort = options.runnerPort
      @configuration.proxyPort = options.proxyPort

      @configuration.environmentID = options.environmentID
      @configuration.appSecret = options.appSecret ? "#{options.environmentID}-app-secret"
      @configuration.masterSecret = options.masterSecret ? "#{options.environmentID}-master-secret"

      @configuration.blRootPath = options.blRootPath

      @dataStore = new KinveyDataStore @configuration

      callback null, this

  runCollectionHook: (collectionName, blFunctionName, request, response, callback) ->
    try
      codeString = getCodeStringFromFilesystem @configuration.blRootPath, config.directories.pathToCollections + '/' + collectionName, blFunctionName
    catch err
      return callback err

    runBLCodeString @configuration, codeString, true, collectionName, blFunctionName, request, response, callback

  runCustomEndpoint: (endpointName, request, response, callback) ->
    try
      codeString = getCodeStringFromFilesystem @configuration.blRootPath, 'endpoints', endpointName
    catch err
      return callback err

    runBLCodeString @configuration, codeString, false, endpointName, 'onRequest', request, response, callback

  runFunction: (codeToRun, request, response, callback) ->
    switch typeof codeToRun
      when 'string' then codeString = codeToRun
      when 'function' then codeString = Function::toString(codeToRun)
      else return callback new Error 'codeToRun must be a function or a stringified function'

    codeString = getCommonBLCode(@configuration.blRootPath) + codeString

    runBLCodeString @configuration, codeString, false, 'runFunction', 'onRequest', request, response, callback

module.exports =
  createClient: (options, callback) ->
    new KinveyBusinessLogicClient options, callback

  createMockRequest: (fromJSON) ->
    return new KinveyMockRequest fromJSON

  createMockResponse: (fromJSON) ->
    return new KinveyMockResponse fromJSON
